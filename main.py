# Инкапсуляция - внутрянка класса, которая недоступна пользователю. Скрытые данные и методы - напрямую обращаться нельзя

# Наследование классов - каждый дочерний объект имеет все свойства и методы родительского класса

# Полиморфизм - можно единым образом работать с разными типами данных

def lesson_1():
    class Point:
        """Аннотация для описания класса и вызывается по Point.__doc__ или pt.__doc__"""

        color = 'red'  # атрибуты или свойства класса
        circle = 2

        def __new__(cls, *args, **kwargs):
            print('вызов __new__ для' + str(cls))
            return super().__new__(cls)

        def __init__(self, x=0, y=0):
            print('вызов __init__ для' + str(self))
            self.x = x
            self.y = y

        def __del__(self):
            print('Удаление экземпляра' + str(self))

        def set_coords(self, x, y):  # self -  ссылка на экземпляр класса
            self.x = x               # добавляет локальные атрибуты в конкретный экземпляр класса
            self.y = y

        def get_coords(self):
            return self.x, self.y

    a = Point()   # создание объекта класса
    b = Point()   # создание другого объекта класса

    type(a)                     # Покажет, что а = принадлежит классу Point
    print(type(a) is Point)     # Покажет True, т.к. тип объекта класса и есть класс
    isinstance(a, Point)        # Покажет True, т.к. тип объекта класса и есть класс

    Point.circle = 1   # переопределение значения свойства класса Point

    a.color = 'green'   """ Переопределение значения свойства класса Point внутри объекта класса, 
                        т.е. у класса Point.color == 'red', а у a.color == 'green'.
                        После этогоо a.__dict__ уже не будет пустым """

    # Свойства:
    print(Point.__dict__)   # Покажет все атрибуты класса Point
    print(a.__dict__)       # Будет пустым, т.к. а берет атрибуты у родительского класса, а сам остается пустым
    print(Point.__doc__)    # Возвращает документацию класса

    # Функции:
    # Обращение к несуществующему свойству или методу класса вызовет ошибку:
    print(Point.a)              # отдаст значение атрибута, но если "а" - несуществующий атрибут Point то будет ошибка
    getattr(Point, 'a')         # другой способ получить значение атрибута, но если "а" существует, иначе будет ошибка
    getattr(Point, 'a', False)  # другой способ получить значение атрибута, но без ошибки, вместо нее вернет False

    # Проверка атрибута в классе по имени атрибута:
    hasattr(Point, 'prop')   # проверяем, есть ли такой атрибут в классе Point
    hasattr(a, 'circle')     # покажет не только атрибуты объекта, но и атрибуты класса

    # Динамическое добавление нового атрибута класса Point или изменение существующего:
    Point.type_pt = 'disc'      # напрямую
    setattr(Point, 'prop', 1)   # через setattr

    # Удаляет атрибут по имени атрибута:
    del Point.prop            # Удаляет атрибут класса, но если такого атрибута нет - будет ошибка
    delattr(Point, 'pt')      # Другой способ удалить атрибут, при отсутствии атрибута тоже будет ошибка
    del a.circle              # Будет ошибка, т.к. circle присутствует в классе Point, но не определен в объекте
    del a.color               # Удалит значение color в а, т.е. 'green' и значение color вернется к дефолтному 'red'


def lesson_2():
    class Point:
        color = 'red'  # атрибуты или свойства класса
        circle = 2

        def __new__(cls, *args, **kwargs):
            print('вызов __new__ для' + str(cls))
            return super().__new__(cls)

        def __init__(self, x=0, y=0):
            print('вызов __init__ для' + str(self))
            self.x = x
            self.y = y

        def __del__(self):
            print('Удаление экземпляра' + str(self))

        def set_coords(self, x, y):  # self -  ссылка на экземпляр класса
            self.x = x  # добавляет локальные атрибуты в конкретный экземпляр класса
            self.y = y

        def get_coords(self):
            return self.x, self.y

    pt = Point()                        # создаем экземпляр класса
    pt.set_coords(1, 2)           # во входные данные для функции автоматически подставляется self
    Point.set_coords(pt, 1, 2)    # то же самое, что и pt.set_coords()
    print(pt.__dict__)                  # отдает свойства экземпляра класса, которые созданы методом set_coords()
    print(pt.get_coords())

    pt2 = Point()
    pt2.set_coords(10, 20)

    # Имена методов класса set_coords, get_coords это те же самые атрибуты, только они ведут не на данные,
    # а на функции. Self - это ссылка на конкретный объект класса.


def lesson_3():
    """ Магические методы класса облагаются двумя подчеркнутыми линиями с обеих сторон __init__, __del__
    Инициализация:
    __init__ и все, что описано в init создается в любом экземпляре класса по-умолчанию
    Финализация:
    __del__ вызывается перед удалением объекта класса, когда на него ничего не ссылается.

    Например, мы создали pt = Point(), а потом переопределили pt = 0.
    Но объект класса Point остался в памяти, хотя его переменная больше на него не ссылается.
    В таком случае происходит удаление объекта. И перед удалением будет вызван метод __del__ """

    class Point:
        "Класс"
        color = 'red'  # атрибуты или свойства класса
        circle = 2

        def __new__(cls, *args, **kwargs):
            print('вызов __new__ для' + str(cls))
            return super().__new__(cls)

        def __init__(self, x=0, y=0):
            print('вызов __init__ для' + str(self))
            self.x = x
            self.y = y

        def __del__(self):
            print('Удаление экземпляра' + str(self))

        def set_coords(self, x, y):  # self -  ссылка на экземпляр класса
            self.x = x  # добавляет локальные атрибуты в конкретный экземпляр класса
            self.y = y

        def get_coords(self):
            return (self.x, self.y)

    alco = Point(1, 3)    # Создаем объект класса, ссылка на объект хранится в alco
    print(alco)                 # Объект существует, alco ссылается на экземпляр класса
    print(alco.color)           # Экземпляр класса имеет доступ к атрибутам класса
    alco = 0                    # alco теперь ссылается на другой объект и на экземпляр класса нет внешних ссылок
    # вызывается метод __del__ и происходит удаление объекта


def lesson_4():
    """
    __new__ и singleton
    в __new__(cls) - cls это ссылка на текущий класс(на Point)
    а self ссылается экземпляр класса
    Все классы в python3 наследуются от object, где уже определен магический метод __new__(cls)
    и при создании класса __new__ должен возвращать адрес на создаваемый экземпляр класса,
    который мы берем из скрытого родителя object методом super().__new__(cls)

    т.е. __new__ существует в object, и мы его переопределяем в Point

    Паттерн Singleton - это создание только одного экземпляра класса. При создании экземпляра класса мы проверяем,
    был ли уже создан экземпляр класса, и если нет - создаем его. Если же экземпляр класса уже создан,
    то новая переменная будет ссылаться на уже существующий экземпляр класса
    """
    class DataBase:
        __instance = None   # ссылка на экземпляр класса

        def __new__(cls, *args, **kwargs):
            if cls.__instance is None:                 # если ссылки нет
                cls.__instance = super().__new__(cls)  # то мы создаем ссылку, беря ее у родительского класса object

            return cls.__instance                      # возвращаем ссылку на созданный экземпляр класса

        def __del__(self):
            DataBase.__instance = None

        def __init__(self, user, psw, port):
            self.user = user
            self.psw = psw
            self.port = port

        def connect(self):
            print(f'Соединение с БД: {self.user}, {self.psw}, {self.port}')

        def close(self):
            print('Закрытие соединения с БД')

        def read(self):
            return 'Данные из БД'

        def write(self, data):
            print(f'Запись в БД {data}')


def lesson_5():
    """
    Декораторы @classmethod и @staticmethod

    @classmethod используется внутри класса, но не принадлежит его экземплярам, работает только с атрибутами класса
    @staticmethod не имеют доступа к атрибутам класса, ни к атрибутам его экземпляров. Такой метод работает
    сам по себе

    Обычные методы класса подразумеваются, что с они будут работать с экземплярами класса и с атрибутами класса

    """
    class Vector:
        MIN_COORD = 0
        MAX_COORD = 100

        @classmethod    # определяется на уровне класса и работает исключительно с методами класса,
                        # и не может обращаться к локальным атрибутам экземпляров класса
        def validate(cls, arg):
            return cls.MIN_COORD <= arg <= cls.MAX_COORD

        def __init__(self, x, y):
            self.x, self.y = 0, 0
            if self.validate(x) and self.validate(y):       # Прописывать имя класса внутри класса плохая практика
                self.x = x
                self.y = y

        def get_coord(self):
            return self.x, self.y

        @staticmethod       # используются без дополнительных аргументов, только то, что принимает метод
        def norm2(x, y):
            return x * x + y * y

    v = Vector(1, 3)
    Vector.validate(5)      # метод класса вызывается без аргумента cls, потому что он подставляется из коробки
    res = v.get_coord()     # или Vector.get_coord(v)
    print(res)


def lesson_6():
    """
    Атрибут - public публичное свойство
    _атрибут - protected режим доступа (внутренняя служебная переменная и сигнал его не трогать)
    __атрибут - private режим доступа (служит для обращения только внутри класса)

    Суть инкапсуляции - взаимодействовать с атрибутами класса только через публичные методы

    Приватными могут быть и методы и атрибуты, и обозначаются __метод

    Для лучшей защиты методов и атрибутов класса, можно использовать модуль accessify
    pip install accessify
    """
    from accessify import private, protected

    class Poind:
        def __init__(self, x=0, y=0):
            self.__x, self.__y = 0, 0
            if self.__check_value(x) and self.__check_value(y):
                self.__x = x
                self.__y = y

        @private      # более надежная защита метода, даже через _Poind__check_value не получится обратиться
        @classmethod  # объявляем метод методом класса и вместо ссылки на экземпляр класса даем ссылку на сам класс
        def __check_value(cls, x):  # метод может использоваться только внутри класса и доступа к нему извне нет
            return type(x) in (int, float)  # проверка на то, что значение является числом

        def set_coord(self, x, y):
            if self.__check_value(x) and self.__check_value(y):
                self.__x = x
                self.__y = y
            else:
                raise ValueError('Координаты должны быть числами')

        def get_coord(self):
            return self.__x, self.__y

    pt = Poind(1, 2)
    pt.set_coord(20, 10)          # сеттеры - передавать значения и проверять допустимость значений
    pt.get_coord()                      # геттеры - получать значения
    print(dir(pt))                      # отобразить все свойства класса от pt
    print(pt._Poind__x)                 # плохой пример обращения к скрытым атрибутам
    print(pt._Poind__check_value(5))    # стоит @private из accessify и доступ к методу запрещен



